# HashiCorp Vault SSH Secrets Engine Demo

## Signed SSH Certifcates

This demo builds a container from Redhat's Universal Base Image to contain an
SSH server, and then imports the SSH server's host key into a Vault server's
SSH secrets engin.  Vault is then used to sign an arbitrary SSH public key,
which can then be used to login to the container via SSH.

## Requirements

* `docker` -- Container runtime to build the container, and spin up the SSH server
* `jo` -- CLI utility for conveniently converting basic `key=value` statements into valid JSON
* `vault` -- This demo assumes a Vault dev server is running and listening on port 9210.  The following command can be used to stand up a Vault dev server in a separate terminal:

```
vault server \
  -dev \
  -dev-root-token-id=root \
  -dev-listen-address=localhost:9210 \
  -log-level=trace
```

## Usage

After installing and setting up the requirements, run the `./setup.sh` script
to build and run the SSH container, and configure your Vault server.  The
`cleanup.sh` script will stop the SSH container and remove any key generated by
the script.


## Step-by-step Explanation

### Building the Container

The `Dockerfile` is used to install and configure an SSH server (`sshd`) inside
of the Redhat UBI image, as well as add a Linux user and generate an SSH
keypair.

* Installing the SSH server:

```
FROM redhat/ubi8

RUN dnf update -y && dnf install -y openssh-server
```

* Configuring `sshd` 

First, we disable password authentication over SSH:

```
RUN sed -i -e 's/^PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config
RUN echo 'ChallengeResponseAuthentication no' >> /etc/ssh/sshd_config
```

Then we specify a file that will contain a Certificate Authority (CA) key to be trusted:

```
RUN echo 'TrustedUserCAKeys /etc/ssh/trusted-CA.pem'  >> /etc/ssh/sshd_config
```

Next, we specify a user principal that will be allowed to authenticate if we find that their key is trusted:

```
RUN mkdir /etc/ssh/auth_principals
RUN echo 'ssh-user' > /etc/ssh/auth_principals/ssh-user
RUN echo 'AuthorizedPrincipalsFile /etc/ssh/auth_principals/%u' >> /etc/ssh/sshd_config
```

* Generating SSH host keys

Here, we generate different host keys using different algorithms.  I think I
opted for this because it was easier than figuring out how to get `sshd` to
accept running with just an RSA key.

For conveniences sake, we'll use the host's RSA key as our trusted CA in Vault,
so we'll create the `/etc/ssh/trusted-CA.pem` we specified in the `sshd` config
by copying the RSA public key. 

```
RUN ssh-keygen -q -f /etc/ssh/ssh_host_rsa_key -N "" -t rsa
RUN ssh-keygen -q -f /etc/ssh/ssh_host_ecdsa_key -N "" -t ecdsa
RUN ssh-keygen -q -f /etc/ssh/ssh_host_ed25519_key -N "" -t ed25519
RUN cp /etc/ssh/ssh_host_rsa_key.pub /etc/ssh/trusted-CA.pem
```

* Add a user account, setting a password and generating an SSH key-pair

This adds the user we'll be authenticating as to the container, sets a password
so we can test and confirm that password auth doesn't work, and generates its
own RSA key-pair.  We will have Vault sign this public key, which we can then
use to authenticate into the container.

```
RUN adduser ssh-user
RUN echo 'ssh-user:ssh-password' | chpasswd
RUN su ssh-user -c 'ssh-keygen -t rsa -b 2048 -f ~/.ssh/id_rsa -N ""'
```

* Start the SSH server

This opens the default SSH port (22) and makes sure the SSH service is running
when we deploy the container:

```
EXPOSE 22
CMD [/usr/sbin/sshd, -D, -e]
```

### Configuring Vault

The `setup.sh` script will collect the necessary keys we generated in the
previous step and use them to configure the SSH Secrets Engine in your Vault
dev server, before demonstrating SSH authentication using the `ssh-user`'s
public key.

* Build and deploy the SSH container:

This uses the `Dockerfile` to build the container in your local image cache,
and then deploys it with port 22 exposed.

```
docker build . -t rhel-ssh
docker run --name rhel-ssh -dit -p 22:$CONTAINER_PORT rhel-ssh
```

* Copy the host and user keys from the container:

We gather the keys we need for Vault, ensuring that appropriate permissions are
set (Vault and most other utilities will complain if your private keys have
`read` permission for anyone other than the "owner"):

```
mkdir ./keys
docker cp rhel-ssh:/etc/ssh/ssh_host_rsa_key ./keys/ssh_host_rsa_key
docker cp rhel-ssh:/etc/ssh/ssh_host_rsa_key.pub ./keys/ssh_host_rsa_key.pub
docker cp rhel-ssh:/home/ssh-user/.ssh/id_rsa.pub ./keys/id_rsa.pub
docker cp rhel-ssh:/home/ssh-user/.ssh/id_rsa ./keys/id_rsa
chmod go-r ./keys/id_rsa
```

* Configure the SSH Secrets Engine:

Here we enable the SSH secrets engine, and configure the CA to use the private host key we generated for the SSH server in the container.  Remember, we're only using the host key for convenience's sake; you can use any private key you want, so long as the SSH server knows to trust it (via the `TrustedUserCAKeys` option for `sshd`).

```
vault secrets enable ssh
vault write ssh/config/ca \
¦ private_key=@./keys/ssh_host_rsa_key \
¦ public_key=@./keys/ssh_host_rsa_key.pub
```

We'll then configure a role to sign public keys with a certificate that specify the `ssh-user` we created in the container.  The `permit-pty` extension is what will let the user land in an interactive shell (e.g., `sh`, `bash`, `zsh`) after it successfully authenticates.


```
jo \
  key_type=ca \
  allow_user_certificates=true \
  allowed_users=ssh-user \
  default_user=ssh-user \
  allowed_extensions=permit-pty \
  default_extensions=$(jo -- -s permit-pty='') |
  vault write ssh/roles/ssh-user -
```

I used `jo` because it's terribly convenient while you're working at the CLI.  An equivalent command using JSON would be as follows:

```
vault write ssh/roles/ssh-user - << EOF
{"key_type":"ca","allow_user_certificates":true,"allowed_users":"ssh-user","default_user":"ssh-user","allowed_extensions":"permit-pty","default_extensions":{"permit-pty":""}}
EOF
```

* Ask Vault to sign the public key and SSH into the container

With everything in place, you can now authenticate to Vault and ask it sign the public key we wish to use to auth to the SSH container:

```
vault write -field=signed_key ssh/sign/ssh-user public_key=@./keys/id_rsa.pub > ./keys/id_rsa.cert
chmod go-r ./keys/id_rsa.cert
```

We now specify our private key and signed public key as our credentials when SSHing to the container:

```
/usr/bin/ssh -i ./keys/id_rsa -i ./keys/id_rsa.cert -l ssh-user localhost -p 22
```

Et Voila!  Any public key you can get Vault to sign (that is to say, that you're able to successfully authenticate and POST to the `/v1/ssh/sign/ssh-user` endpoint) can now be used to authenticate to the SSH server.  For example, we can generate an entirely new SSH key, sign its pubkey, and then immediately use it to SSH:

```
ssh-keygen -t rsa -b 2048 -q -N "" -f ./foo_rsa
vault write -field=signed_key ssh/sign/ssh-user public_key=@./foo_rsa.pub > foo_rsa.cert
ssh -i foo_rsa -i foo_rsa.cert ssh-user@localhost -p 22
```



